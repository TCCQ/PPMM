Things to do and think about:

what do I need to do to setup the PM for the first time?

we need to be careful, shm does not allow for mapping to a fixed address.

could solve with a PMptr type, is an offset from the base pointer

then have getAddr(PMptr) that returns a void*. so read/writes to the
data use that, and storing the pointer themselves should just store
PMptr type

--------------------------------------------------------------------------
how do unix process restarts work? How should procIDX inheritance work?

-------------------------------------------------------------------------
how do atomics work in memmapped files, and what is the read write timing? can two processes cam b->a and c->a in one spot at the same time. b->a succeeds, c->a fails, and both think they succeeded? should it be b->d, c->e? can I read a location I just cam'd? do I need to flush between? 

------------------------------------------------------------------------
Capsules need to be small enough to be written atomically, or the currentlyInstalled/reset pointer needs to be indirect so it can be atomically swapped. Capsules never need to be CAM'd, so there is not a hard size requirement iirc.

JOBs need to be CAM-able. using gcc atomic compare and swap stuff means they should be 1,2,4,8 bytes, but they include a capsule struct in them currently, which contains an ARGUMENT_SIZE byte buffer in them. We could have dynamically allocated capsules, which doesn't seem feasible. we could have dynamic arguments, but then to garbage collect each struct would need a pointer to its args and then another to the last cap.s that it needs to clean. This is unreasable are pointers are usually 3-4 bytes long.

ANSWER I make the currentlyInstalled a back-and-forth swap, see trampolineCapsule. See comments at CAMJob for more thoughts on job caming. confirm

------------------------------------------------------------------------
Fix the issue with taken jobs not writing the capsule into the new local job entry

ANSWER I think I fixed this in helpThief? confirm

------------------------------------------------------------------------
consider declaring all of the Capsule func(void) stuff as funcPtr_t func for readability, and to make it clear that they don't take argument in the normal way. Mostly stylistic

------------------------------------------------------------------------
do the intial setup, all the PM setup, procIdx mapping and setting all the pointer and whatnot, see top of scheduler.c and bottom of scheduler.h

------------------------------------------------------------------------
PM pointers should probably be declared as volatile, could make a def/ for that for readability
#define PM volatile
PM int* top; or whatever

------------------------------------------------------------------------
rewrite the scheduling code to use PMem and persistent stack properly. avoid Capsule types in arguments, and Jobs, as they include a Capsule.

TODO Consider if I need to go deeper and have a real Pstack, not just an array, so I can store bigger arguments.

------------------------------------------------------------------------
how do all these setup things work? should I declare them all extern?

figure out later

------------------------------------------------------------------------
how do I pass arguments through the scheduler?

currently args are through the stack, but that is not possible. Should
I add an argument field to a job? then copy it to the stack on the
start? that is what makes the most sense to me
